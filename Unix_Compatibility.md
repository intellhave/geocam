# Unix Compatibility #

## Keywords ##
Unix, Mac, Macintosh, compatibility, organization, makefile, build, compiling

## Author ##
Joe Thomas

Ideally, any of the code we write for this project should be easy to compile on a Windows or Unix-based machine. In practice, this is may not be the case, because:

  1. Information describing how to compile the project to a working executable may be automatically generated by an IDE (like `Dev-C++`), and this script may not be immediately portable to another machine.
  1. The dependency structure between modules may not be obvious (perhaps because unnecessary `#include` statements appear in the source code).
  1. The source code may assume the project has a particular directory structure.
  1. The project assumes particular platform-specific commands or utilities are present (like `sed`).

Consequently, in addition to the Windows version of our project, we also have a concurrent Unix version that is basically equivalent. This project shares no source code with the windows version (in the interest of not breaking the Windows developers work), but most of the files differ very little from their windows counterparts.

The Unix version may have value to the programmer who wants...
  * code to run custom experiments on a unix platform (like one of the high-performance machines).
  * to study a small subset of the project to understand how the project as a whole is organized.
  * to see the project decomposed into individually compilable modules.

Currently, the Unix branch of our project is stored within the directory `unix`. It consists of four directories: `topology`, `utils`, `ehr_geometry`, and `newtons_method`. The first three directories are examples of general-purpose modules:
  * `topology` implements a data structure for storing triangulations.
  * `utils` provides utilities for common tasks like reading/writing a triangulation to/from a file.
  * `ehr_geometry` implements a memoized pipeline for fast calculation of particular quantities defined on the triangulation.

In contrast, `newtons_method` provides an example of an "experimental" module. In this module, the programmer (the author) wrote a pair of files (`main.cpp` and `Pipelined_Newtons_Method.cpp`) to try to use Newton's Method to minimize the value of the Einstein Hilbert Regge functional over the radii. This module makes use of the other modules to build and run the experiment. With further development and documentation, an experimental module might itself become a general-purpose module that can be used by others.

Each of the general-purpose modules are designed to encapsulate solutions to one major problem (either mathematical or practical). Each contains a makefile that compiles all of the source in that directory to one static archive. So, for example, the `ehr_geometry` module contains a `geometry.a` archive that contains all of the necessary compiled code for the module. When a programmer wants to use the procedures or data structures in `ehr_geometry`, he needs to do two things. First, he needs to use the `-iquote[module location]` or `-Iquote[module location]` option on the compiler to tell it where headers for the module can be found. Second, when producing the final executable he should link in `geometry.a`.


